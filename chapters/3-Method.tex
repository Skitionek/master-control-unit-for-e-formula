%!TEX root = ../Thesis.tex

% 3. Method section
% In a scholarly research article, the section dealing with method is very important. The same applies to an empirical thesis. For students, this can be a difficult section to write, especially since its purpose may not always be clear.

% The method chapter should not iterate the contents of methodology handbooks. For example, if you have carried out interviews, you do not need to list all the different types of research interview. You also do not need to describe the differences between quantitative and qualitative methods, or list all different kinds of validity and reliability.

% What you must do is to show how your choice of design and research method is suited to answering your research question(s). Demonstrate that you have given due consideration to the validity and reliability of your chosen method. By “showing” instead of “telling”, you demonstrate that you have understood the practical meaning of these concepts. This way, the method section is not only able to tie the different parts of your thesis together, it also becomes interesting to read!

% Show the reader what you have done in your study, and explain why. How did you collect the data? Which options became available through your chosen approach?
% What were your working conditions? What considerations did you have to balance?
% Tell the reader what you did to increase the validity of your research. E.g., what can you say about the reliability in data collection? How do you know that you have actually investigated what you intended to investigate? What conclusions can be drawn on this basis? Which conclusions are certain and which are more tentative? Can your results be applied in other areas? Can you generalise? If so, why? If not, why not?
% You should aim to describe weaknesses as well as strengths. An excellent thesis distinguishes itself by defending – and at the same time criticising – the choices made.

\chapter{Method}

% Having not sufficient financial support enforced many compromises on design which I did not have direct influence on. The decision was made that will be running in low voltage - high current setup so we could use cost-efficient lithium-ion batteries. 
% Although theoretically possible cabling and connector sizing was a bit overwhelming for responsible teams.


\begin{figure}[b]
    \centering
        \includegraphics[width=0.8\textwidth]{figures/silverstone.jpg}
        \caption{Built car on Silverstone race circuit}
        \ref{pic:silverstone}
\end{figure}


We\todo{is it right to say we?} have built an electric car from scratch based on buggy frame, where all the pipes are welded together and all the components directly attached to it. Although in this solution, all the vibrations are transferred to the driver (reducing his comfort) it is a durable and light solution - the aspects which were the most important due to the racing character of the vehicle. 

In our final setup we used:
\begin{itemize}
    \item Two EMRAX228 motors which nominal power of about 50kW (when liquid cooled)
    \item Two emDrive500 controllers capable full usage of AM motors
    \item Arduino with CAN shields to act as intelligent sensors/controllers
    \item Two IWAKI direct drive pumps (RD-40E24-HN1V) pumps for cooling purposes
    % \begin{wrapfigure}
    %     \includegraphics[width=0.33\textwidth]{figures/Pump.pdf}
    % \end{wrapfigure}
    \item National Instruments' cRIO-9033 as a main control unit
\end{itemize}

This result in the system which in a simplified manner has been presented in figure \ref{fig:whole}.

\begin{figure}[h]
    \centering
    \includegraphics{figures/whole.pdf}
    \caption{Architecture overview}
    \label{fig:whole}
\end{figure}

As shown all the communication with the master control unit is based on CAN bus (CANOpen is based on CAN bus). 






All small subsystems are based on Arduino evaluation boards.




As previously mentioned the main control unit has been deployed on cRIO9033 - National Instruments' controller equipped with a real-time processor and re-configurable FPGA unit. The reasoning for usage of this device was that it has more than sufficient computation power for the task and with additional modules provides support for basic CAN communication as well as high-level CANOpen abstraction.


In my setup, I have been using module NI9853 to directly receive and send a CAN messages and NI9881 for communication with the motor controllers based on CANOpen standard.

\section{Master control unit software implementation}
From the early beginning, I have been developing the code of master control unit using event-based programming paradigm. The reasoning of this is asynchronous, real-time nature of such unit.

Most simple classification of subsystems can be based on communication protocol being used. 

\subsection{Communication protocols}

\subsubsection{CAN integration}
To start with I had to implement a CAN library which would let me service messages from the code running on the real-time processor. I did it based on one of the provided examples, however, to meet my needs it required some ground modifications.

Especially functionality which has been missing is the ability to wait for a message with a certain id, one from an array of ids or just any message. 
\paragraph{Reading}

To achieve it, I have a functionality deployed on FPGA (Field Programmable Gate Array) which simply translates input/output messages into the arrays of 8x unsigned integers. Read messages are furthermore pushed into the FIFO register. In parallel, a consumer process is running which takes messages from the register set it as an output and raise an interrupt on the real-time processor to notify that data is ready to be read.

Upon initiation of the device, a programme is run on the real-time processor which besides the main process spawns an additional one in the background. This one furthermore is responsible for communication with the FPGA so whenever a message arrives it services interrupt by copying it and sends the acknowledge back to FPGA so next one can be transmitted. Meanwhile, CAN frame is stored in the table indexed by its ID and two notifications are sent (for the desired frame and for the arrival of any message)\footnote{Usage of LabVIEW synchronisation primitive "Queue".}% further described in \todo{queue description}}.

Now depending on a place in the code read function can be called in one of three ways:
\begin{description}[labelindent=1cm]
    \item[Read All] - function blocks the thread until notification arrives that any message has been received (or upon timeout) and returns it. Example of usage would be a logging purpose.
    \item[Read Some] - for given list of message IDs function behaves similarly to "Read All". However, notification is read and check if contains one of the listed IDs if not it starts again and return frame upon success (or error upon timeout). Example - Error handler.
    \item[Read ID] - waits for notification associated with the certain ID. Example - read pedal position.
    
%     Then look up table is check for the existence of a conditional variable for given id, it is created if does not exist, and updated with a new message. Additionally, a conditional variable containing the id of last received message id is updated.

% Based to this architecture I implemented functions which can wait for any message, one with a certain id or one from ids set.

\end{description}

\paragraph{Writing}
For sending a message it simply pushes data to FPGA and marks it as ready to send. FPGA is constantly checking the ready to send status and whenever it becomes true sends the data.

\vspace{5mm}
\noindent Thank this architecture CAN messaging part is easy to use, read and modify.

\subsubsection{CANOpen}
For the simplicity and maximum throughput although CANOpen is an abstraction layer over CAN bus an additional line has been used only for CANOpen communication. It has been used just to link two motor controllers and NI-9881 module (plugged into cRIO).

For the usage, CANOpen seemed like the best choice. It provides great flexibility in the way that all parameters can be accessed the way as they would be stored in memory registry without any pre-configuration. Furthermore, if setup correctly certain number of parameters can be accessed without any protocol overhead providing maximum bus throughput.

As previously mentioned in \ref{can_subprotocol} CANOpen abstraction consists of 6 complementary sub-protocols.
\begin{description}[labelindent=1cm]
    \item[NMT] Network management - Provides unified control over the devices state (Boot up, Pre-operational, Operational, Stopped)
    \item[SDO] Service Data Object - verbose protocol by default providing access to all the parameters of the device, it works based on two messages schema first describing which data should be sent next then in second sending actual data
    \item[PDO] Process Data Object - configurable sets of parameters to send/receive upon change or after SYNC message
    \item[SYNC]    Synchronisation Object - issue request of device status
    \item[TIME]    Time Stamp Object - is used to synchronise with device clock and it had no use in this project
    \item[EMCY] Emergency Object - asynchronously broadcast errors
\end{description}

As it meant to be I implemented one drive control based on NMT, SDO, PDO and SYNC protocols. Using NMT to control general state, SDO to control all the parameters before setting the device into operational mode and control device-specific states and PDO combined with SYNC messages to read device status and send control messages.

However, as it came to controlling two motors simultaneously conflicting messages ids in PDO and SYNC protocols needed to be changed. Although many tries it was not possible to change this values. Contacting the manufacturer drop the light on the case as they were aware that their devices malfunctions and were not able to provide any fix for the issue.

So for the two motor configuration, I had to implement a workaround by using slower and not providing all the functionality SDO protocol.
Usage of this protocol caused a drastic drop in channel throughput considering for instance reading of device status:
\begin{table}[H]
\centering
\begin{tabular}{|l|c|}
    \hline
    Data & Data size [byte] \\
    \hline
    Status word & 2 \\
    Controller Temperature & 1 \\
    Motor Temperature & 1 \\
    Error Code & 2  \\
    Error Register & 1 \\
    Torque Actual Value & 2  \\
    Velocity actual Value & 4  \\
    Electrical Angle & 2  \\
    Electric Power & 4 \\
    \hline
    \hfill Sum & 19 \\
    \hline
\end{tabular}
\caption{Motor controller status component sizing}
\end{table}

As each PDO message can contain up to 8 bytes aforementioned list of parameters would need to be divided into 3 CAN frames and as an result $46bits*3+19bytes+\epsilon = 290 bits +\epsilon$  \hspace{0.2cm}\footnote{\label{foot:eps}$\epsilon$ has been used to represent stuffed bits} needs to be send. On the other hand sending the same data with SDO protocol requires request-respond schema for each value so $46bits*18 + 19bytes + 9*4bytes + \epsilon = 1268 bits + \epsilon$ \hspace{0.2cm} \ref{foot:eps} needs to be send.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/CANOpen vs CAN.png}
    \caption{CANOpen vs CAN}
    \label{fig:canopen_bitwise}
    \todo{enrich it by missing fields}
\end{figure}

Furthermore, also the target torque off motor controllers needs to be adjusted SDO messages. In this case, performance drawback is even more visible, if the PDO protocol could be used torque values could be sent together within one CAN frame ($46bits+4bytes=78 bits$), however, within SDO 4 CAN frames needs to be sent ($46bits*4+4bytes+4bytes*2=280bits$).

\subsection{Device operation states}

\begin{wrapfigure}{R}{0.43\textwidth}
    \vspace{-20pt}
    \centering
        \includegraphics[width=0.4\textwidth]{figures/System_overview}
        \label{fig:sys_over}
        \caption{Control unit\newline states overview}
    \vspace{-20pt}
\end{wrapfigure}

The implemented control unit in practice consists of few nested state machines. The most general consist of just 3 states responsible for controller booting, operational and shutdown.
In booting state all initial values are set and internal modules like FPGA, CAN and CANOpen are being turned on in parallel to main threads. Whenever this phase is finished, an error logger is turn on and the car booting sequence begins.

To start with, the dashboard is updated with batteries charge status and systems waits for power up button to be pressed. Whenever driver would command turning of the vehicle button blinks and lights up by internal LED whenever BMS would response with ready to discharge message. Then the second button is required to be pressed in order to turn the traction system on (analogical interface to the first button). Whenever the traction system is first turned on, the controller sends a message to the audio-visual system so the car plays loud sound alerting the surrounding to take cautions as systems are charge and it is ready to drive.

In the operational state, many control loops run in parallel to cover desired vehicle functionality.
\begin{itemize}
    \item Pedals status is read, updates local pedal status and issue notification that motor controllers should be updated with new values. 
    \item Upon notification new target torques values are calculated and send to motor controllers.
    \item Running watchdog, if no pedals update was notified within 500ms set target torques to zero (an emergency mechanism to slow the motors in case of any temporary fail of pedals sensor).
    \item Set pumps to full power for 3s to initiate rotation, then control it accordingly to further mentioned method.\ref{pump_control}
    \item Communicate with BMS to keep it in an operational state.
    \item Read and act upon BMS and low voltage BMS state.
    \item Log all the information.
\end{itemize}


\section{Pedals sensor}
A System to measure pedals and steering wheel position is based on Arduino evaluation board. Which is a simple evaluation setup build upon Atmel ATmega8 with $16MHz$ oscillator.

Now considering the sampling rate of this sub-module it has been programmed to use prescaler for A/D converter with a value of 128. Referring to datasheet basic conversion takes 13 clock cycles so we should except sampling rate of about $16MHz/128/13 = 9615Hz = 104µs$ \cite{Atmega8}.

However, in an electric car, there is a considerable electromagnetic noise which needs to be addressed. To reduce the impact of noise which was significant in the first approach, the code was modified to calculate an average of 10 successive samples efficiently reducing the rate to $1,04ms$.

Considering the fact that ATmega8 consist of just one analogue-decimal converter with multiplexed input the measurement takes approximately $1,04ms * number of sensors$ \cite{Atmega8}.
To satisfy the safety requirements we needed to use two offset sensors for each pedal (accelerator, brake) and one for the steering wheel. In consequence each measurement takes at least $1,04ms * 5 = 5,2ms$.

This system sense all the information which is:
\begin{itemize}
    \item pedals position
    \item steering wheel position
    \item pedals sensors position miss-match
    \item pedals, steering wheel over-travel, under-travel and connection loss errors
\end{itemize}

After the measurement, the information is sent through CAN bus with a baud rate of 500kbit/s (used CAN module was not capable to work with higher baud rates). Pedals position although being read on 10 bits is averaged and only 8 significant bits are sent. We assumed that 256 quantization steps are sufficient in this case. It allowed us to shorten CAN frame to consist of only 4 bytes of data.
Now considering timing, the CAN frame (\ref{fig:CAN_FRAME}) consists of at least 44 basic bits plus 4 bytes of data in our case. The total time of sending/receiving would be therefore $\frac{76}{500kbit/s} = 152us$.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/CAN_FRAME.png}
    \caption{CAN frame structure \cite{CAN_stuffing}}
    \label{fig:CAN_FRAME}
\end{figure}

Assuming no further improvements we should expect the pedals sub-systems is capable of sending the pedals, steering wheel position in a time interval of about $5,2ms$\label{pedal_ideal_time} in normal operation.
Additionally, if any of the above-mentioned errors occurred the second CAN frame is sent containing two bytes with bitwise encoded errors extending the expected interval into $~5,3ms$.

\section{Pump control}\label{pump_control}
In our car, we have used IWAKI RD-40E24-HN1V pumps, which can be controlled by a signal from $0-5V$. Since used Arduino has no dedicated analogue input we made one by using the PWM signal with a low-pass filter.% (direct control by PWM signal was strongly disapproved by the pump manufacturer \todo{cite pump manual}). <= I was told that by mech guys but there is no single word in manual
The subsystem acts simply by controlling pulse width based on the value received by CAN message from the master control unit. It also provides basic emergency behaviour in the manner that if no message was sensed over one second the pumps are turned on to work with full power.






\section{Implementation of electrical differential based on steering angle}\label{diff_meth}
In my implementation I have enriched calculations explained in \ref{diff_calc}. Starting with the steering wheel, the sensor output is normalised to the measured minimum and maximum steering wheel angles ($\pm123\deg$) so the meaningful value can be shown in remote control panel as well as saved in logs. 
Then since it is linearly proportional it is simply converted to steering angle ($\pm35\deg$). To prevent any miss usage all the values are coerced on the go to be within the ranges.

Having commanded output power (in percentage) basic differential functionality could be obtained just by multiplying it with a maximum allowed/available torque and proportion on per wheel base. However, it would start failing for power close to $100\% $, although total torque will remain under the limit, the outer wheel can go above the limit by up to ($20\% $).
This situation would be especially dangerous if the maximum torque per wheel base would start to saturate. In this case, the differential would gradually stop to function effectively by pushing the car out of the desired curve.
To avoid this miss-behaviour I added the code to check if after previous calculation any of the wheels is about to be set to more than maximum torque and scale both of them accordingly.
\begin{equation}\label{diff_saf}
    \tau_{left,right} = \begin{cases}
        \tau_{left,right} = P * \gamma_{left,right} * \tau_{max} & \text{se $m(P,\gamma_{left,right}) \leq 1$}\\
        \tau_{left,right} = P * \gamma_{left,right} * \tau_{max} / m(P,\gamma_{left,right}) & \text{se $m(P,\gamma_{left,right}) > 1$}\\
    \end{cases}
\end{equation}
Where:
\begin{description}
    \item[P] desired output power ($0-100\%$)
    \item[$\tau_{max}$] maximum torque per wheel
    \item[$\tau$] wheel torque
    \item[$\gamma$] differential disproportion of wheel ($\gamma_{left}+\gamma_{right}=200\%$)
    \item[$m(P,\gamma{left,right})$] $= P * max(\gamma_{left},\gamma_{right})$
\end{description}

\section{Regenerative braking}
As mentioned in theory chapter (\ref{regenerative_theory_section}) the regenerative braking cannot be used in low speeds. Normally this problem would be solved by varying the braking force between regenerative and friction breaks. However, the car design did not take into the account the possibility to electrically control the friction breaks. So I implemented an alternative solution taking into account this technical obstacle and comfort of the driver.
Considering regenerative braking as negative torque system which I have implemented can be expressed by equation \ref{reg_break_eq}.


\begin{equation*}
    \tau = \begin{cases}
        D & \text{se $V_{avg} \leq 10km/h$}\\
        (V_{norm,10-20} * 15\% + 100\%) * D - V_{norm,10-20} * 15\% & \text{se $V_{avg} \in (10km/h,20km/h>$}\\
        115\% * D - 15\% & \text{se $V_{avg} > 20km/h$}\\
    \end{cases}
    \label{reg_break_eq}
\end{equation*}
Where:
\begin{description}
    \item[$V_{avg}$] average velocity of the wheels 
    \item[$V_{norm,10-20}$] $V_{avg}$ normalised in range from 10 to 20 ($V_{norm,10-20}=(V_{avg}-10)/10$)
    \item[D] acceleration pedal displacement in percentage
    \item[$tau$] percentage of used torque (in reference to maximum value)
\end{description}

It follows the simple idea to use a variable portion of pedal displacement for regenerative braking based on speed.
When the user presses the acceleration pedal in a stationary vehicle the whole available scale is used to control torque giving an expected instant response. After reaching $10km/h$ the pedal displacement used for regenerative braking increases gradually to reach $15\%$ while travelling with speed equal to or higher than $20km/h$.

What else is worth to mention is that as a result for the pedal displacement from $0-15\%$ we should expect the car to act as it would be controlled in speed mode.\label{speed_mode} The characteristic would be firstly saturated by low torque however within enough power to make the car accelerate we should be able to observe a linear correlation between pedal displacement and speed.

To summarise the expected idealised correlation between torque, pedal displacement and speed has been shown in figure \ref{fig:regen_ideal}.

\begin{figure}[H]
    \centering
        \includegraphics[height=5.8cm]{figures/regen_ideal}
        \caption{Regenerative braking / torque control}
        \label{fig:regen_ideal}
\end{figure}




